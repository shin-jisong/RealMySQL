# 4.1 MySQL 엔진 아키텍처

## 4.1.1 MySQL의 전체 구조
MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다
MySQL의 전체 구조에서 볼 때 MySQL 엔진에는 커넥션 핸들러, SQL 인터페이스, SQL 파서, SQL 옵티마이저, 캐시 & 버퍼로 이루어져 있다

### 4.1.1.1 MySQL 엔진
SQL 분장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행
서버당 하나가 존재

- 커넥션 핸들러: 클라이어느로부터 접속 및 쿼리 요청을 처리
- SQL 파서 및 전처리기
- 옵티마이저: 쿼리의 최적화 실행
- 
### 4.1.1.2 스토리지 엔진
실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분
서버당 여러 개가 존재 가능
성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능 내장

### 4.1.1.3 핸들러 API
핸들러 요청: MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는 것
핸들러 API: 핸들러 요청에서 사용되는 API

## 4.1.2 MySQL 스레딩 구조
MySQL 서버는 프로세스 기반이 아니라 스레드 기반 
<details>
<summary>프로세스와 스레드의 차이</summary>
<div markdown="1">
| 구분         | 프로세스(Process)                        | 스레드(Thread)                               |
|--------------|-------------------------------------------|-----------------------------------------------|
| 정의         | 실행 중인 독립된 프로그램                 | 프로세스 내에서 실행되는 작업 단위            |
| 메모리 구조  | 각 프로세스는 독립된 메모리 공간 가짐     | 프로세스의 메모리(코드, 힙 등)를 공유         |
| 스택         | 각자 별도의 스택 사용                     | 각 스레드는 고유한 스택을 가짐                |
| 생성 비용    | 높음 (OS 리소스 많이 필요)                | 낮음 (경량화되어 빠름)                        |
| 통신 방식    | IPC(파이프, 소켓 등)를 통해 통신           | 공유 메모리를 통해 직접 통신 가능             |
| 안정성       | 높음 (문제가 생겨도 다른 프로세스 영향 없음)| 낮음 (공유 자원으로 인해 동기화 문제 발생 가능) |
| 예시         | 크롬 창 여러 개, 터미널에서 실행한 프로그램 | 하나의 서버에서 여러 요청을 처리하는 스레드  |
</div>
</details>
포그라운드 스레드와 백그라운드 스레드로 구분 가능

### 4.1.2.1 포그라운드 스레드 (클라이언트 스레드)
최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로
이때 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게
최대 스레드 개스는 thread_chace_size 시스템 변수로 설정

데터를 MysQL 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스트의 데이터나 인덱스 파일로부터 데이터를 읽어왓 ㅓ작업을 처리
MyISAM 테이블은 디스크 쓰기 작업까지 처리
InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리
<details>
<summary>MyISAM 테이블? InnoDB 테이블?</summary>
<div markdown="1">
InnoDB vs MyISAM (MySQL 저장 엔진 비교)

| 항목               | InnoDB                                 | MyISAM                                 |
|--------------------|------------------------------------------|------------------------------------------|
| ✅ 트랜잭션 지원   | O (지원)                                 | X (미지원)                               |
| 💥 ACID 준수       | O (Atomicity, Consistency, etc.)         | X                                        |
| 🔗 외래 키(Foreign Key) | O (지원)                             | X (미지원)                               |
| 🔒 잠금 방식        | 레코드 단위 잠금 (Row-level Locking)     | 테이블 단위 잠금 (Table-level Locking)   |
| 💽 충돌 시 복구    | 자동 복구 지원 (Crash-safe)             | 복구 불가 (손상 위험)                    |
| 📈 읽기 성능       | 보통 (쓰기와 병행 처리 시 좋음)         | **빠름** (읽기 전용에 적합)              |
| ✍️ 쓰기 성능       | 동시성 좋음 (다중 사용자 환경 적합)      | 동시 쓰기 성능 낮음                      |
| 🔍 FullText 검색   | MySQL 5.6 이상부터 지원                  | 기본적으로 지원                          |
| 🗃️ 저장 방식       | 데이터 + 인덱스 통합 저장 (.ibd 파일)     | 데이터(.MYD), 인덱스(.MYI) 분리 저장     |
| 🔧 사용 목적        | **기본 엔진**, 대부분의 웹서비스에 적합 | 단순 읽기/로그 저장 등 특정 용도에 적합  |

> ✅ InnoDB는 **기본/권장** 저장 엔진이며, MySQL 5.5 이상부터 기본입니다.
> 🔍 MyISAM은 과거에 사용되었으나, 트랜잭션이 필요 없는 단순 검색용 테이블에만 제한적으로 사용됩니다.
</div>
</details>

### 4.1.2.2 백그라운드 스레드
MyISAM의 경우에는 해당 없음
InnoDB의 경우 아래 작업이 백그라운드로 처리
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 **로그 스레드**, 데이터를 디스크로 내려쓰는 작업을 처리하는 **쓰기 스레드**
MySQL5.5버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드 개수를 2개 이상 지정 가능, `innodb_write_io_threads`, `innodb_read_io_threads` 시스템 변수로 스레드의 개수 설정
데이터 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드 많이 설정 필요 X, 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 충분히 설정

데이터 쓰기 작업은 지연 가능, 읽기 작업은 지연 X
InnoDB: 쓰기 작업은 버퍼링해서 일괄 처리
MyISAM: 사용자 스레드가 쓰기 작업까지 함께 처리, 쓰기 버퍼링 기능 사용 불가

## 4.1.3 메모라 할당 및 구조

- 글로벌 메모리 영역
  MySQL 서버가 시작되면서 운영체제로부터 할당
- 로컬 메모리 영역

서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분

### 4.1.3.1 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당
필요에 따라 2개 이상의 메모리 고간을 할당 받을 수 있음
모든 스레드에 의해 공유됨
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 4.1.3.2 로컬 메모리 영역
서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
클라이언트가 서버에 접속하면 서버에서 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라 **클라이언트 메모리 영역**이라고도 함
클라이언트와 서버와의 커넥션을 세션이라고 하기 때문에 **세션 메모리 영역**이라고도 표현

각 클라이언트 스레드별로 독립적으로 할당, 절대 공유되어 사용되지 않음
각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않을 경우에는 메모리 공간을 할당조차도 하지 않을 수도 있음
계속 할당된 상태로 남아 있는 공간도 있고, 쿼리 실행 순간에만 할당했다가 다시 해제하는 공간도 있음
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

## 4.1.4 플러그인 스토리지 엔진 모델
MySQL은 스토리지 엔진뿐 아니라 인증, 검색 파서, 사용자 인증 등 다양한 기능을 플러그인으로 제공
사용자가 직접 스토리지 엔진을 개하는 것도 가능

- 쿼리 실행 과정
  SQL 파서 -> SQL 옵티마이저 -> SQL 실행기 -> 데이터 읽기 / 쓰기 -> 디스트
  즉, 대부분의 쿼리 처리는 MySQL 엔진 영역에서,
  데이터의 실제 읽기/쓰기는 스토리지 엔진 단에서 처리
  사용자가 새로운 용도의 스토리지 엔진을 만들어도, 일부 기능만 수행하는 엔진을 작성하게 됨

## 4.1.5 컴포넌트
기존의 플러그인 아키텍처를 대체하기 위해 **컴포넌트 아키텍처**가 지원됨
- 플러그인은 오직 MySQL 서버와 인터ㅔ이스할 수 있고, 플러그인끼리는 통신할 수 없음
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 X)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움nnoDB의 경우 아래 작업이 백그라운드로 처리
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 **로그 스레드**, 데이터를 디스크로 내려쓰는 작업을 처리하는 **쓰기 스레드**
MySQL5.5버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드 개수를 2개 이상 지정 가능, `innodb_write_io_threads`, `innodb_read_io_threads` 시스템 변수로 스레드의 개수 설정
데이터 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드 많이 설정 필요 X, 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 충분히 설정

데이터 쓰기 작업은 지연 가능, 읽기 작업은 지연 X
InnoDB: 쓰기 작업은 버퍼링해서 일괄 처리
MyISAM: 사용자 스레드가 쓰기 작업까지 함께 처리, 쓰기 버퍼링 기능 사용 불가

## 4.1.3 메모라 할당 및 구조

- 글로벌 메모리 영역
  MySQL 서버가 시작되면서 운영체제로부터 할당
- 로컬 메모리 영역

서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분

### 4.1.3.1 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당
필요에 따라 2개 이상의 메모리 고간을 할당 받을 수 있음
모든 스레드에 의해 공유됨
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 4.1.3.2 로컬 메모리 영역
서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
클라이언트가 서버에 접속하면 서버에서 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라 **클라이언트 메모리 영역**이라고도 함
클라이언트와 서버와의 커넥션을 세션이라고 하기 때문에 **세션 메모리 영역**이라고도 표현

각 클라이언트 스레드별로 독립적으로 할당, 절대 공유되어 사용되지 않음
각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않을 경우에는 메모리 공간을 할당조차도 하지 않을 수도 있음
계속 할당된 상태로 남아 있는 공간도 있고, 쿼리 실행 순간에만 할당했다가 다시 해제하는 공간도 있음
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

## 4.1.4 플러그인 스토리지 엔진 모델
MySQL은 스토리지 엔진뿐 아니라 인증, 검색 파서, 사용자 인증 등 다양한 기능을 플러그인으로 제공
사용자가 직접 스토리지 엔진을 개하는 것도 가능

- 쿼리 실행 과정
  SQL 파서 -> SQL 옵티마이저 -> SQL 실행기 -> 데이터 읽기 / 쓰기 -> 디스트
  즉, 대부분의 쿼리 처리는 MySQL 엔진 영역에서,
  데이터의 실제 읽기/쓰기는 스토리지 엔진 단에서 처리
  사용자가 새로운 용도의 스토리지 엔진을 만들어도, 일부 기능만 수행하는 엔진을 작성하게 됨

## 4.1.5 컴포넌트
기존의 플러그인 아키텍처를 대체하기 위해 **컴포넌트 아키텍처**가 지원됨
- 플러그인은 오직 MySQL 서버와 인터ㅔ이스할 수 있고, 플러그인끼리는 통신할 수 없음
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 X)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
  

## 4.1.6 쿼리 실행 구조
쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기

### 4.1.6.1 쿼리 파서
사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어내는 작업
기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지 전달

### 4.1.6.2 전처리기
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정
실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러짐nnoDB의 경우 아래 작업이 백그라운드로 처리
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 **로그 스레드**, 데이터를 디스크로 내려쓰는 작업을 처리하는 **쓰기 스레드**
MySQL5.5버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드 개수를 2개 이상 지정 가능, `innodb_write_io_threads`, `innodb_read_io_threads` 시스템 변수로 스레드의 개수 설정
데이터 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드 많이 설정 필요 X, 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 충분히 설정

데이터 쓰기 작업은 지연 가능, 읽기 작업은 지연 X
InnoDB: 쓰기 작업은 버퍼링해서 일괄 처리
MyISAM: 사용자 스레드가 쓰기 작업까지 함께 처리, 쓰기 버퍼링 기능 사용 불가

## 4.1.3 메모라 할당 및 구조

- 글로벌 메모리 영역
  MySQL 서버가 시작되면서 운영체제로부터 할당
- 로컬 메모리 영역

서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분

### 4.1.3.1 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당
필요에 따라 2개 이상의 메모리 고간을 할당 받을 수 있음
모든 스레드에 의해 공유됨
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 4.1.3.2 로컬 메모리 영역
서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
클라이언트가 서버에 접속하면 서버에서 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라 **클라이언트 메모리 영역**이라고도 함
클라이언트와 서버와의 커넥션을 세션이라고 하기 때문에 **세션 메모리 영역**이라고도 표현

각 클라이언트 스레드별로 독립적으로 할당, 절대 공유되어 사용되지 않음
각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않을 경우에는 메모리 공간을 할당조차도 하지 않을 수도 있음
계속 할당된 상태로 남아 있는 공간도 있고, 쿼리 실행 순간에만 할당했다가 다시 해제하는 공간도 있음
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

## 4.1.4 플러그인 스토리지 엔진 모델
MySQL은 스토리지 엔진뿐 아니라 인증, 검색 파서, 사용자 인증 등 다양한 기능을 플러그인으로 제공
사용자가 직접 스토리지 엔진을 개하는 것도 가능

- 쿼리 실행 과정
  SQL 파서 -> SQL 옵티마이저 -> SQL 실행기 -> 데이터 읽기 / 쓰기 -> 디스트
  즉, 대부분의 쿼리 처리는 MySQL 엔진 영역에서,
  데이터의 실제 읽기/쓰기는 스토리지 엔진 단에서 처리
  사용자가 새로운 용도의 스토리지 엔진을 만들어도, 일부 기능만 수행하는 엔진을 작성하게 됨

## 4.1.5 컴포넌트
기존의 플러그인 아키텍처를 대체하기 위해 **컴포넌트 아키텍처**가 지원됨
- 플러그인은 오직 MySQL 서버와 인터ㅔ이스할 수 있고, 플러그인끼리는 통신할 수 없음
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 X)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움nnoDB의 경우 아래 작업이 백그라운드로 처리
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 **로그 스레드**, 데이터를 디스크로 내려쓰는 작업을 처리하는 **쓰기 스레드**
MySQL5.5버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드 개수를 2개 이상 지정 가능, `innodb_write_io_threads`, `innodb_read_io_threads` 시스템 변수로 스레드의 개수 설정
데이터 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드 많이 설정 필요 X, 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 충분히 설정

데이터 쓰기 작업은 지연 가능, 읽기 작업은 지연 X
InnoDB: 쓰기 작업은 버퍼링해서 일괄 처리
MyISAM: 사용자 스레드가 쓰기 작업까지 함께 처리, 쓰기 버퍼링 기능 사용 불가

## 4.1.3 메모라 할당 및 구조

- 글로벌 메모리 영역
  MySQL 서버가 시작되면서 운영체제로부터 할당
- 로컬 메모리 영역

서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분

### 4.1.3.1 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당
필요에 따라 2개 이상의 메모리 고간을 할당 받을 수 있음
모든 스레드에 의해 공유됨
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 4.1.3.2 로컬 메모리 영역
서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
클라이언트가 서버에 접속하면 서버에서 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라 **클라이언트 메모리 영역**이라고도 함
클라이언트와 서버와의 커넥션을 세션이라고 하기 때문에 **세션 메모리 영역**이라고도 표현

각 클라이언트 스레드별로 독립적으로 할당, 절대 공유되어 사용되지 않음
각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않을 경우에는 메모리 공간을 할당조차도 하지 않을 수도 있음
계속 할당된 상태로 남아 있는 공간도 있고, 쿼리 실행 순간에만 할당했다가 다시 해제하는 공간도 있음
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

## 4.1.4 플러그인 스토리지 엔진 모델
MySQL은 스토리지 엔진뿐 아니라 인증, 검색 파서, 사용자 인증 등 다양한 기능을 플러그인으로 제공
사용자가 직접 스토리지 엔진을 개하는 것도 가능

- 쿼리 실행 과정
  SQL 파서 -> SQL 옵티마이저 -> SQL 실행기 -> 데이터 읽기 / 쓰기 -> 디스트
  즉, 대부분의 쿼리 처리는 MySQL 엔진 영역에서,
  데이터의 실제 읽기/쓰기는 스토리지 엔진 단에서 처리
  사용자가 새로운 용도의 스토리지 엔진을 만들어도, 일부 기능만 수행하는 엔진을 작성하게 됨

## 4.1.5 컴포넌트
기존의 플러그인 아키텍처를 대체하기 위해 **컴포넌트 아키텍처**가 지원됨
- 플러그인은 오직 MySQL 서버와 인터ㅔ이스할 수 있고, 플러그인끼리는 통신할 수 없음
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 X)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
  

## 4.1.6 쿼리 실행 구조
쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기

### 4.1.6.1 쿼리 파서
사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어내는 작업
기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지 전달

### 4.1.6.2 전처리기
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정
실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러짐

### 4.1.6.3 옵티마이저
사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할 (두뇌에 해당)

### 4.1.6.4 실행 엔진
만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

### 4.1.6.5 핸들러 (스토리지 엔진)
MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할

## 4.1.7 복제
이후 언급 예정

## 4.1.8 쿼리 캐시
SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능
but, 테이블의 데이터가 변경되면 저장된 결과 중에서 변경된 테이블과 관련된 것들을 모두 삭제
-> 심각한 동시 처리 성능 저하 유발
**현재는 기능에서 완전히 제거됨**

## 4.1.9 스레드 풀
내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도
MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
-> 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처리가 더 느려지는 사례도 발생할 수 있음
제한된 수의 스레드만으로 CPU가 처리하도록 적절히 유도한다면 CPU의 프로세서 친화도는 높이고, 운영체제 입장에서 불필요한 컨텍스트 스위치를 줄여서 오버헤드 낮출 수 있음

기본적으로는 CPU 코어의 개수만큼 스레드 그룹을 생성, 스레드 그룹의 개수는 `thread_pool_size` 시스템 변수로 조정 가능
서버가 처리해야 할 요청이 생기면 스레드 풀로 처리를ㄹ 이관하는데, 스레드 풀이 처리 중인 작업이 있는 경우 `thread_pool_oversubscribe` 시스템 변수에 설정된 개수만큼 추가로 더 받아들여서 처리
이 값이 너무 크면 스케줄링 해야할 스레드가 많아져서 스레드 풀이 비효율적으로 작동

스레드 그룹의 모든 스레드가 일하고 있다면 스레드 풀ㄹ은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부 판단 필요
**타이머 스레드**: 주기적으로 스레드 그룹의 상태를 체그해서 정의도니 밀리초만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새로운 스레드 생성해서 스레드 그룹에 추가
이때 전체 스레드 풀에 있는 스레그 개수는 설정된 개수를 넘어설 수 없음

선순위 큐와 후순위 큐를 사용해서 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공
잠금이 빨리 해제되고 잠금 경합을 낮춰서 전체적인 처리 성능 향상

## 4.1.10 트랜잭션 지원 메타데이터
**데이터 딕셔너리 또는 메타데이터**: 테이블 구조 정보와 스토어드 정보 
기존 버전에서는 파일 기반으로 관리 but 생성 및 변경 작업이 트랜잭션을 지원하지 않아 테이블의 생성 또는 변경 도중에 비정상적 종료 시 일관되지 않는 상태로 남는 문제

현재 버전에서는 모두 InnoDB 테이블에 저장하도록 개선
시스템 테이블(사용자 인증, 권한 관련 등) 모두 InnoDB 스토리지 엔진 사용
시스템 테이블과 데이터 딕셔너리 정보를 모두 모아 mysql DB에 저장
mysql DB는 통째로 mysql.ibd라는 이름의 테이블스페이스에 저장

8.0버전부터는 데이터 딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선 
-> 비정상적 종료되어도 완전 성공 혹은 완전 실패

서버에서 MyISAM이나 CSV 등과 같은 스토리지 엔진의 메타 정보는 여전히 저장할 공간이 필요
-> SDI (Serialized Dictionary Informaion) 파일 사용
기존의 FRM 파일과 동일한 역할, 직렬화를 위한 포맷

